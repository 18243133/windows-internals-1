## Securing Windows Objects

### Security Attributes

Nearly all of the Windows API calls that begin with the `Create` prefix allow one to specify the security attributes of the object that is under construction. The security attributes are specified by way of a `SECURITY_ATTRIBUTES` structure.

```
typedef struct _SECURITY_ATTRIBUTES
{
    DWORD nLength,
    LPVOID lpSecurityDescriptor,
    BOOL bInheritHandle
} SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES;
```

It is clear from the structure definition that the pointer to the security descriptor is the primary member of interest of this structure. The `bInheritHandle` flag specifies whether the handle may be inherited by other processes (e.g. children created by `CreateProcess()`).

### Security Descriptor

Object _security descriptors_ are one side of the object security equation (the other being _access tokens_). Among other things, an object's security descriptor specifies the entities that may performa ations on an objects and which actions they may perform.

An object security descriptor has multiple, distinct access control lists embedded within it:

- _DACL_ -> discretionary access control list
    - Access control entries in this list specify a SID and the rights granted to that SID
- _SACL_ -> system access control list
    - Specifies which actions by which users should be logged
    - If a SACL is null, no auditing occurs for that object 

A new security descriptor object may be initialized with the following APIs:

- `InitializeSecurityDescriptor()`
- `SetSecurityDescriptorOwner()`
- `SetSecurityDescriptorGroup()`
- `InitializeAcl()`
- `AddAccessDeniedAce()`
- `AddAccessAllowedAce()`
- `AddAuditAccessAce()`
- `SetSecurityDescriptorDacl()`
- `SetSecurityDescriptorSacl()`

Notice that there is no concept of a "denied" ACE for system ACLs.

The access control entries of an object's DACL and SACL are scanned sequentially by the security reference monitor when performing an access check. Therefore, the order in which ACEs are added to a security descriptor's DACL and SACL is important.

An ACE consists of a SID and the _access mask_ associated with that SID. The access mask specifies the access rights to be allowed or denied to the specified SID. 

Mask values will vary by object type. So how do we determine the appropriate ACE mask values to apply to a given kernel object?

- Read the docs (sometimes useful)
- Read header files _winnt.h_ and _winbase.h_

**Security Descriptor Control Flags**

The control flags control the meaning assigned to the security descriptor.

- `GetSecurityDescriptorControl()`
- `SetSecurityDescriptorControl()`

In addition to the latter of the two functions above, the control bits of a security descriptor may also be modified implicitly by other security descriptor manipulation APIs.

The control flags for a security descriptor specify properties such as the inheritance properties of the security descriptor DACL and SACL, and whether or not SD is absolute or self-relative.

**Absolute vs Self-Relative Security Descriptors**

An absolute security descriptor is the kind which is generated by a call to `InitializeSecurityDescriptor()` - these are the security descriptors that are often manipulated by processes. However, absolute security descriptors cannot be associated with persistent objects like files because they reference data in memory and will thus become invalidated when the process manipulated the security descriptor terminates.

Windows defines a second type of security descriptor, a self-relative security descriptor, that is a compacted version of the absolute security descriptor. Windows automatically consolidates an absolute SD to a self-relative SD when the SD is associated with a persistent object.

Convert between the two types of SDs manually using the following APIs:

- `MakeAbsoluteSD()`
- `MakeSelfRelativeSD()`

**Security Descriptor APIs**

Query security descriptors with the following API functions:

- `GetSecurityInfo()`
- `GetKernelObjectSecurity()`
- `SetKernelObjectSecurity()`
- `GetFileSecurity()`
- `GetNamedSecurityInfo()`
- `GetSecurityDescriptorOwner()`
- `GetSecurityDescriptorGroup()`
- `GetSecurityDescriptorDacl()`
- `GetSecurityDescriptorSacl()`
- `GetAclInformation()`
- `GetAce()`

Further APIs exist specifically for querying the security descriptor of files:

- `GetFileSecurity()`
- `SetFileSecurity()`

**Kernel Debugging**

- The pointer to the security descriptor is in the object header of the `EPROCESS` object
- Use the `!sd` command to dump the security descriptor
- Caveat here about bitwise-anding the pointer first because some bits of the address are used as flags??? (&-10 on 64 bit system) e.g !sd <addr> & -10 (64 bit)

### Security Identifier (SID)

Instead of using names to identify entities which perform actions within a system, Windows uses SIDs. 

**Which entities are issued a SID?**

- Users
- Local and domain groups
- Local computers
- Domains
- Domain members
- Services

**SID components**

- ‘S’ prefix
- SID structure revision number
- 48 bit authority value -> who issued the SID
- Variable number of
    - 32 bit sub authority values
    - Relative identifier (RID) values

Standard Windows APIs allow one to query the SID for a specified account name and vice versa.

### Access Tokens (aka Tokens)

**What is a token?**

An _access token_ is associated with a process. The token specifies the owning user of the process and the groups to which the user belongs.

- Identify the security context of a process or thread
- Identify a user’s (entity’s?) credentials, and thus their privileges
- When user logs in, LSASS checks if the user is a member of a powerful group or possesses a powerful privilege; if this is the case, LSASS creates a restricted token (a filtered admin token) for the user in addition to the powerful one, and creates a logon session for each

**Access Tokens APIs**

- `LogonUser()`
- `CreateProcessAsUser()`
- `CreateProcessWithLogon()`
- `AdjustTokenGroups()`
- `AdjustTokenPrivileges()`
- `OpenProcessToken()`
- `CreateProcessWithToken()`
- `DuplicateToken()`
- `DuplicateTokenEx()`

**Token Components**

- Group SIDs -> identify the groups to which the user represented by the token belongs
- Privilege array
- Default primary group, default DACL -> used when the process associated with this token creates an object, applied as default security policy
- Many other "informational" fields

**Trust ACEs**

- Allow protected processes and PPL to make objects accessible only to other protected processes
- Identified by well-known SIDs
- Higher trust SID = more powerful token
- Listed in the kernel debugger as "TrustLevelSid" within the token object

**Kernel Debugging**

- Use dt _TOKEN to view token structure
- Use the !token command to examine token for a process

### Integrity Levels

- Orthogonal to access control?
- We can isolate code and data running within the context of a user account
- 6 levels commonly used
    - 0 = untrusted
    - 5 = protected
- For instance, mark an untrusted process like a web browser with a low integrity level, will prevent it from doing certain things
- Processes have integrity levels, but so do other objects 
- Windows enforces a "No Write Up" policy by default such that a process may not "write" any object that is configured with a higher integrity level
    - e.g. Run notepad.exe at low intergity level and you won't be able to save a new file to any location other than the LocalLow directory
- Implicit medium integrity level system-wide

### References

- _Windows System Programming, 4th Edition_ Pages 519-544
- _Windows Internals, 7th Edition_ Pages 619-666
- _Windows Internals, 7th Edition_ Pages 668-675